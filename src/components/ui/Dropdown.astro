---
interface MenuItem {
  label: string;
  value?: string;
  icon?: string;
  disabled?: boolean;
  href?: string;
  children?: MenuItem[];
}

interface Props {
  items: MenuItem[];
  variant?: "initial" | "retro" | "modern" | "futuristic";
  position?: "bottom-left" | "bottom-right" | "top-left" | "top-right";
  triggerLabel?: string;
  triggerIcon?: string;
  openOnHover?: boolean;
  class?: string;
}

const {
  items,
  variant = "initial",
  position = "bottom-left",
  triggerLabel = "Menu",
  triggerIcon,
  openOnHover = false,
  class: className,
} = Astro.props;

const dropdownId = `dropdown-${Math.random().toString(36).substring(2, 11)}`;
const dropdownClass = [
  "dropdown",
  openOnHover && "dropdown-hover",
  variant !== "initial" && variant,
  className,
].filter(Boolean).join(" ");

// Name pour les radio buttons de chaque niveau
const level1RadioName = `${dropdownId}-level1`;
const getLevel2RadioName = (parentId: string) => `${dropdownId}-level2-${parentId}`;
---

<div class={dropdownClass}>
  <input type="checkbox" id={dropdownId} class="dropdown-state" />
  
  <label for={dropdownId} class="dropdown-trigger">
    {triggerIcon && <span class="trigger-icon">{triggerIcon}</span>}
    <span class="trigger-label">{triggerLabel}</span>
    <span class="trigger-arrow">▼</span>
  </label>
  
  <label for={dropdownId} class="dropdown-backdrop"></label>
  
  <div class={`dropdown-menu position-${position}`}>
    <div class="dropdown-content">
      {items.map((item) => {
        const itemId = `${dropdownId}-${item.value || (item.label ? item.label.replace(/\s+/g, '-').toLowerCase() : 'item')}`;
        const hasChildren = item.children && item.children.length > 0;
        
        if (hasChildren) {
          return (
            <div class="dropdown-submenu">
              <input type="radio" name={level1RadioName} id={itemId} class="submenu-state" />
              {item.href ? (
                <a href={item.href} class={item.disabled ? "dropdown-item has-submenu has-link disabled" : "dropdown-item has-submenu has-link"}>
                  {item.icon && <span class="item-icon">{item.icon}</span>}
                  <span class="item-label">{item.label}</span>
                  <label for={itemId} class="submenu-arrow-trigger">
                    <span class="submenu-arrow">▶</span>
                  </label>
                </a>
              ) : (
                <label for={itemId} class={item.disabled ? "dropdown-item has-submenu disabled" : "dropdown-item has-submenu"}>
                  {item.icon && <span class="item-icon">{item.icon}</span>}
                  <span class="item-label">{item.label}</span>
                  <span class="submenu-arrow">▶</span>
                </label>
              )}
              <div class="submenu-content">
                <div class="dropdown-content">
                  {item.children!.map((child) => {
                    const childId = `${itemId}-${child.value || (child.label ? child.label.replace(/\s+/g, '-').toLowerCase() : 'child')}`;
                    const hasGrandChildren = child.children && child.children.length > 0;
                    
                    if (hasGrandChildren) {
                      return (
                        <div class="dropdown-submenu">
                          <input type="radio" name={getLevel2RadioName(itemId)} id={childId} class="submenu-state" />
                          {child.href ? (
                            <a href={child.href} class={child.disabled ? "dropdown-item has-submenu has-link disabled" : "dropdown-item has-submenu has-link"}>
                              {child.icon && <span class="item-icon">{child.icon}</span>}
                              <span class="item-label">{child.label}</span>
                              <label for={childId} class="submenu-arrow-trigger">
                                <span class="submenu-arrow">▶</span>
                              </label>
                            </a>
                          ) : (
                            <label for={childId} class={child.disabled ? "dropdown-item has-submenu disabled" : "dropdown-item has-submenu"}>
                              {child.icon && <span class="item-icon">{child.icon}</span>}
                              <span class="item-label">{child.label}</span>
                              <span class="submenu-arrow">▶</span>
                            </label>
                          )}
                          <div class="submenu-content">
                            <div class="dropdown-content">
                              {child.children!.map((grandChild) => {
                                if (grandChild.href) {
                                  return (
                                    <a href={grandChild.href} class={grandChild.disabled ? "dropdown-item disabled" : "dropdown-item"}>
                                      {grandChild.icon && <span class="item-icon">{grandChild.icon}</span>}
                                      <span class="item-label">{grandChild.label}</span>
                                    </a>
                                  );
                                }
                                return (
                                  <label for={dropdownId} class={grandChild.disabled ? "dropdown-item disabled" : "dropdown-item"}>
                                    {grandChild.icon && <span class="item-icon">{grandChild.icon}</span>}
                                    <span class="item-label">{grandChild.label}</span>
                                  </label>
                                );
                              })}
                            </div>
                          </div>
                        </div>
                      );
                    }
                    
                    if (child.href) {
                      return (
                        <a href={child.href} class={child.disabled ? "dropdown-item disabled" : "dropdown-item"}>
                          {child.icon && <span class="item-icon">{child.icon}</span>}
                          <span class="item-label">{child.label}</span>
                        </a>
                      );
                    }
                    
                    return (
                      <label for={dropdownId} class={child.disabled ? "dropdown-item disabled" : "dropdown-item"}>
                        {child.icon && <span class="item-icon">{child.icon}</span>}
                        <span class="item-label">{child.label}</span>
                      </label>
                    );
                  })}
                </div>
              </div>
            </div>
          );
        }
        
        if (item.href) {
          return (
            <a href={item.href} class={item.disabled ? "dropdown-item disabled" : "dropdown-item"}>
              {item.icon && <span class="item-icon">{item.icon}</span>}
              <span class="item-label">{item.label}</span>
            </a>
          );
        }
        
        return (
          <label for={dropdownId} class={item.disabled ? "dropdown-item disabled" : "dropdown-item"}>
            {item.icon && <span class="item-icon">{item.icon}</span>}
            <span class="item-label">{item.label}</span>
          </label>
        );
      })}
    </div>
  </div>
</div>

<script is:inline define:vars={{ dropdownId, openOnHover }}>
  // Script pour la détection de collision avec les bords de l'écran
  if (typeof window !== 'undefined') {
    // Ensure dropdownId is defined
    const id = typeof dropdownId !== 'undefined' ? dropdownId : 'dropdown-default';
    const dropdown = document.querySelector(`#${id}`)?.closest('.dropdown');
    if (!dropdown) return;
    
    const menu = dropdown.querySelector('.dropdown-menu');
    const submenus = dropdown.querySelectorAll('.submenu-content');
    
    function checkCollision(element) {
      if (!element) return;
      
      const rect = element.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      
      // Check si le submenu sort à droite
      if (rect.right > viewportWidth - 20) {
        element.style.left = 'auto';
        element.style.right = '100%';
        element.style.marginLeft = '0';
        element.style.marginRight = '0.25rem';
      }
      
      // Check si le submenu sort en bas
      if (rect.bottom > viewportHeight - 20) {
        element.style.top = 'auto';
        element.style.bottom = '0';
      }
    }
    
    // Observer pour détecter quand les menus s'ouvrent
    const observer = new MutationObserver(() => {
      if (menu && menu.style.visibility === 'visible' || getComputedStyle(menu).visibility === 'visible') {
        checkCollision(menu);
        
        // Check tous les submenus visibles
        submenus.forEach(submenu => {
          if (submenu.style.visibility === 'visible' || getComputedStyle(submenu).visibility === 'visible') {
            checkCollision(submenu);
          }
        });
      }
    });
    
    observer.observe(dropdown, { 
      attributes: true, 
      subtree: true, 
      attributeFilter: ['style', 'class']
    });
    
    // Check initial au hover pour les dropdowns hover
    if (openOnHover) {
      dropdown.addEventListener('mouseenter', () => {
        setTimeout(() => {
          checkCollision(menu);
          submenus.forEach(submenu => {
            if (getComputedStyle(submenu).visibility === 'visible') {
              checkCollision(submenu);
            }
          });
        }, 50);
      });
      
      // Re-check sur submenu hover
      const submenuTriggers = dropdown.querySelectorAll('.dropdown-submenu');
      submenuTriggers.forEach(trigger => {
        trigger.addEventListener('mouseenter', () => {
          setTimeout(() => {
            const submenu = trigger.querySelector('.submenu-content');
            checkCollision(submenu);
          }, 50);
        });
      });
    } else {
      // Pour le mode click, check après l'ouverture
      const checkbox = dropdown.querySelector('.dropdown-state');
      if (checkbox) {
        checkbox.addEventListener('change', () => {
          if (checkbox.checked) {
            setTimeout(() => {
              checkCollision(menu);
            }, 50);
          }
        });
      }
      
      // Check sur radio change pour submenus
      const radioButtons = dropdown.querySelectorAll('.submenu-state');
      radioButtons.forEach(radio => {
        radio.addEventListener('change', () => {
          if (radio.checked) {
            setTimeout(() => {
              const parent = radio.closest('.dropdown-submenu');
              const submenu = parent?.querySelector('.submenu-content');
              checkCollision(submenu);
            }, 50);
          }
        });
      });
    }
  }
</script>
